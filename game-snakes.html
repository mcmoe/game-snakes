<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-icons/av-icons.html">
<link rel="import" href="../paper-fab/paper-fab.html">

<!--
Web component providing a basic configurable snakes game. Use use arrow keys or 'a', 's', 'w', 'd' or touch screen to move.
##### Example:
    <game-snakes></game-snakes>
##### Example with changed size, height, width and time:
	<game-snakes size="40" height="8" width="12" time="600"></game-snakes>
##### Changing style:
	<style>
	
		game-snakes {
			background-color: #4A148C;
		}
	
		/*styling play food*/
		game-snakes::shadow #food {
			border-radius: 2px;
			box-shadow: none;
		}
	
		/*styling snake's tail and head*/
		game-snakes::shadow .tail, game-snakes::shadow #head {
			background-color: transparent;
			background-image: url('../game-snakes/hexagon.png');
			background-repeat: no-repeat;
			background-size: contain;
			box-shadow: none;
		}
	
		/*styling the overlay behind play button*/
		game-snakes::shadow #overlay {
			background-color: rgba(255,255,255,0.54);
		}
	
		/*styling play button*/
		game-snakes::shadow #playButton {
			background-color: #7B1FA2;
		}
	
	</style>
@element game-snakes
@blurb Element providing a basic configurable snakes game.
@status beta
@homepage https://github.com/namannehra/game-snakes/
-->

<polymer-element name="game-snakes" attributes="size height width time">
	<template>
		<style>
			:host {
				display: block;
				-webkit-user-select: none;
				user-select: none;
			}
			#container {
				height: 100%;
				position: relative;
			}
			#food, .tail, #head {
				margin: 2px 0 0 2px;
				position: absolute;
			}
			#food {
				display: none;
				background-color: #FF4081;
				border-radius: 50%;
			}
			.tail {
				background-color: #388E3C;
				border-radius: 2px;
			}
			#head {
				background-color: #212121;
				border-radius: 2px;
			}
			#overlay {
				background-color: rgba(0,0,0,0.54);
				-webkit-transition: opacity 0.4s cubic-bezier(0.4,0,0.2,1);
				transition: opacity 0.4s cubic-bezier(0.4,0,0.2,1);
			}
			paper-fab {
				background-color: #4CAF50;
				margin: auto;
				-webkit-transition: transform 0.4s cubic-bezier(0.4,0,0.2,1);
				transition: transform 0.4s cubic-bezier(0.4,0,0.2,1);
			}
		</style>
		<div id="container" on-trackstart="{{trackstart}}" on-track="{{track}}">
			<div id="food"></div>
			<div id="tails"></div>
			<div id="head"></div>
			<div id="overlay" fit>
				<paper-fab id="playButton" icon="av:play-arrow" on-tap="{{play}}" fit></paper-fab>
			</div>
		</div>
	</template>
	<script>
		Polymer({
			/**
			  * Sets the size of one block in px
			  * @attribute size
			  * @type number
			  * @default 24
			*/
			size: 24,
			/**
			  * Sets the number of blocks in height of the game area
			  * @attribute height
			  * @type number
			  * @default 20
			*/
			height: 20,
			/**
			  * Sets the number of blocks in width of the game area
			  * @attribute width
			  * @type number
			  * @default 20
			*/
			width: 20,
			/**
			  * Sets the time in which snake moves one block in milliseconds (Reducing this value will increase speed of the snake)
			  * @attribute time
			  * @type number
			  * @default 100
			*/
			time: 100,
			/**
			  * Returns the current score
			  * @attribute score
			  * @type number
			  * @default 0
			*/
			score: 0,
			/**
			  * Returns true if game is running
			  * @attribute playing
			  * @type boolean
			  * @default false
			*/
			playing: false,
			ready: function() {
				this.style.height = this.height * this.size + 'px';
				this.style.width = this.width * this.size + 'px';
				this.$.food.style.height = this.size - 4 + 'px';
				this.$.food.style.width = this.size - 4 + 'px';
				this.$.head.style.height = this.size - 4 + 'px';
				this.$.head.style.width = this.size - 4 + 'px';
				this.begin();
			},
			begin: function() {
				this.direction = 'none';
				this.headTop = this.height * this.size / 2 - this.size;
				this.headLeft = this.width * this.size / 2 + this.size;
				this.tailTop = [this.headTop, this.headTop, this.headTop];
				this.tailLeft = [this.headLeft - (3 * this.size), this.headLeft - (2 * this.size), this.headLeft - this.size];
				this.$.container.removeAttribute('touch-action');
				this.$.head.style.top = this.headTop + 'px';
				this.$.head.style.left = this.headLeft + 'px';
				for (var i = 0; i < 3; i++) {
					this.setTail();
					this.tail.id = 'tail' + i;
					this.tail.style.top = this.tailTop[i] + 'px';
					this.tail.style.left = this.tailLeft[i] + 'px';
					this.$.tails.appendChild(this.tail);
				}
				this.createFood();
			},
			createFood: function() {
				loop:for (var i = 1; i > 0; i++) {
					this.foodTop = Math.floor(Math.random() * this.height) * this.size;
					this.foodLeft = Math.floor(Math.random() * this.width) * this.size;
					for (var i = 0; i <= this.$.tails.childNodes.length; i++) {
						if (this.foodTop == this.tailTop[this.tailTop.length - i] && this.foodLeft == this.tailLeft[this.tailLeft.length - i]) {
							continue loop;
						}
					}
					break;
				}
				this.$.food.style.top = this.foodTop + 'px';
				this.$.food.style.left = this.foodLeft + 'px';
			},
			setTail: function() {
				this.tail = document.createElement('div');
				this.tail.className = 'tail';
				this.tail.style.height = this.size - 4 + 'px';
				this.tail.style.width = this.size - 4 + 'px';
			},
			growTail: function() {
				this.setTail();
				this.tail.id = 'tail' + (this.score + 2);
				this.tail.style.top = this.headTop + 'px';
				this.tail.style.left = this.headLeft + 'px';
				this.async(function() {
					this.$.tails.appendChild(this.tail);
				}, null, this.$.tails.childNodes.length * this.time);
			},
			/**
			  * Starts the game
			  * @method play
			*/
			play: function() {
				this.score = 0;
				this.playing = true;
				this.$.container.setAttribute('touch-action', 'none');
				this.$.food.style.display = 'block';
				this.$.overlay.style.opacity = '0';
				this.$.playButton.style.webkitTransform = 'scale(0)';
				this.$.playButton.style.transform = 'scale(0)';
				this.async(function() {
					this.$.overlay.style.display = 'none';
				}, null, 500);
				document.onkeydown = function(e) {
					if (this.playing) {
						if (!(this.direction == 'up' || this.direction == 'down')) {
							if (e.keyCode == 38 || e.keyCode == 87) {
								this.turn('up');
							}
							if (e.keyCode == 40 || e.keyCode == 83) {
								this.turn('down');
							}
						}
						if (!(this.direction == 'right' || this.direction == 'left')) {
							if (e.keyCode == 39 || e.keyCode == 68) {
								this.turn('right');
							}
							if (this.direction != 'none' && (e.keyCode == 37 || e.keyCode == 65)) {
								this.turn('left');
							}
						}
						return false;
					}
				}.bind(this)
			},
			trackstart: function(e) {
				this.trackstartX = e.clientX;
				this.trackstartY = e.clientY;
				this.trackend = false;
			},
			track: function(e) {
				if (this.playing && !this.trackend) {
					this.trackX = e.clientX - this.trackstartX;
					this.trackY = e.clientY - this.trackstartY;
					if (Math.abs(this.trackX) >= Math.abs(this.trackY) && !(this.direction == 'right' || this.direction == 'left')) {
						if (this.trackX > 0) {
							this.turn('right');
							this.trackend = true;
						} else if (this.trackX < 0) {
							this.turn('left');
							this.trackend = true;
						}
					}
					if (Math.abs(this.trackX) <= Math.abs(this.trackY) && !(this.direction == 'up' || this.direction == 'down')) {
						if (this.trackY > 0) {
							this.turn('down');
							this.trackend = true;
						} else if (this.trackY < 0) {
							this.turn('up');
							this.trackend = true;
						}
					}
				}
			},
			/**
			  * Ends the game
			  * @method end
			*/
			end: function() {
				this.playing = false;
				clearInterval(this.move);
				this.$.overlay.style.display = 'block';
				this.async(function() {
					this.$.food.style.display = 'none';
					this.$.overlay.style.opacity = '1';
					this.$.playButton.style.webkitTransform = 'none';
					this.$.playButton.style.transform = 'none';
					while (this.$.tails.firstChild) {
						this.$.tails.removeChild(this.$.tails.firstChild);
					}
					this.begin();
				}, null, 100);
			},
			turn: function(e) {
				this.direction = e;
				clearInterval(this.move);
				this.moving(e);
				if (this.playing) {
					this.move = setInterval(function() {
						this.moving(e);
					}.bind(this), this.time);
				}
			},
			moving: function(e) {
				this.tailTop[this.tailTop.length] = this.headTop;
				this.tailLeft[this.tailLeft.length] = this.headLeft;
				if (e == 'up') {
					this.headTop -= this.size;
					if (this.headTop < 0) {
						this.end();
					} else {
						this.$.head.style.top = this.headTop + 'px';
					}
				}
				if (e == 'right') {
					this.headLeft += this.size;
					if (this.headLeft >= this.width * this.size) {
						this.end();
					} else {
						this.$.head.style.left = this.headLeft + 'px';
					}
				}
				if (e == 'down') {
					this.headTop += this.size;
					if (this.headTop >= this.height * this.size) {
						this.end();
					} else {
						this.$.head.style.top = this.headTop + 'px';
					}
				}
				if (e == 'left') {
					this.headLeft -= this.size;
					if (this.headLeft < 0) {
						this.end();
					} else {
						this.$.head.style.left = this.headLeft + 'px';
					}
				}
				if (this.playing) {
					for (var i = 0; i < this.$.tails.childNodes.length; i++) {
						this.$.tails.childNodes[i].style.top = this.tailTop[this.tailTop.length - i - 1] + 'px';
						this.$.tails.childNodes[i].style.left = this.tailLeft[this.tailLeft.length - i - 1] + 'px';
					}
				}
				if (this.headTop == this.foodTop && this.headLeft == this.foodLeft) {
					this.score++;
					this.growTail();
					this.createFood();
				}
				for (var i = 0; i < this.$.tails.childNodes.length; i++) {
					if (this.headTop == this.tailTop[this.tailTop.length - i - 1] && this.headLeft == this.tailLeft[this.tailLeft.length - i -1]) {
						this.end();
						break;
					}
				}
			},
			/**
			  * Fired whenever the score changes
			  * @event score
			*/
			scoreChanged: function() {
				this.fire('score');
			},
			/**
			  * Fired when the game starts or ends
			  * @event playing
			*/
			playingChanged: function() {
				this.fire('playing');
			}
		});
	</script>
</polymer-element>
